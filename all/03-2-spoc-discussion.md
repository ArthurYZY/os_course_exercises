# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
  1. 为什么要设计非连续内存分配机制？

* 解决内存分配可能会产生的内存碎片的问题，提高内存的利用率
* 提高内存分配的灵活性，方便动态进行调整


  1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

* 大小选择多样，有大块的段也有小块的页
* 页和段的大小也不一定一样，也可以选择


  1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

* 大块的灵活性没有小块高，但是大小可变一定程度上提高了灵活性。
* 小块本身灵活性很高，但是相对也比较难以管理，固定大小方便对齐让小块内存更好管理。
* 小块的固定大小也有多种选择

### 6.2	段式存储管理
  1. 什么是段、段基址和段内偏移？

* 段是在内存中划分的，访问方式和访问的数据属性相似的一个段地址空间
* 段基址指的是一个段的起始地址
* 段内偏移指的是地址相对于段基址的偏移量


  1. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

* 首先通过段号在段表中查找到相应的段，之后在通过段内偏移找到实际的地址
* 段一定程度上反映了程序的存储逻辑结构，程序是无法从一个段通过偏移访问到另一个段的，因此段在内存上不需要连续。
* 好处就是提高了内存管理的灵活性，坏处就是地址转化更加复杂，提升了管理的难度


### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

* 页是一段连续的逻辑地址空间
* 帧是一段连续的物理地址空间
* 页表是一个存在于内存中的储存页到帧的映射关系的表
* 存储管理单元管理逻辑地址到物理地址映射的硬件
* 块表是页表的缓存，用来减少虚实地址转换的硬件
* 高速缓存是对内存的高速缓存，用来减少访存时间的硬件

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

* 首先利用逻辑地址的页号查找页表，找到物理页面然后通过页内偏移找到物理地址
* 因为有页表在管理逻辑页面到物理页面的映射关系，因此连续的逻辑页面可以映射到不连续的物理页面上，
* 这样做的好处就是提高了内存管理的灵活性，提高了内存的利用率，方便内存的分配与回收，麻烦就是地址转换比较复杂，需要消耗额外的时间和空间。


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

页表的内容会因操作系统的不同而不同，一般会有

* 存在位：表示页目前是否在内存中
* 修改位：表示次表项所指的页是否写过数据
* 引用位：表示此页是否被访问过
* 只读位：表示相应的页是否是只读的

 1. 页表大小受哪些因素影响？

* 页的大小，地址空间大小，进程数


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

* TLB缓存的是页表，cache缓存的是内存

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

* 因为TLB是在CPU中的和内存用的存储介质不同，因此访问速度快，但是价格昂贵功耗高，所以容量很小。
* 块表的实现方法就是将一部分页表缓存起来，利用了局部性原理。如果缓存失效了就对缓存进行更新

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

* 多级页表就是将原来的一个页表变成若干层级，一层一层查找
* 转换流程就是通过多级页表号从第一级查起一级一级往下查找，最后一级别存储着对应的物理地址
* 好处就是节省了页表的空间，因为不是每一级的页表都全被利用了，坏处就是增加了虚实地址转换时间并且让页表管理更加困难


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

* 逻辑地址进行hash然后和页寄存器的值进行比较，如果产生冲突则在冲突链上继续查找

 1. 反置页表机制的地址转换流程是什么？

* 逻辑地址和进程号一同进行hash然后在相应的页寄存器中查找

 1. 反置页表项有些什么内容？

* PID，逻辑页号，标志位

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

* 先查段表然后再查相应段的页表
* 好处：利用了段在内存保护方面的优势，以及页在内存利用和优化以及转移到后背存储方面的优势
* 坏处：增加了内存管理的复杂度，不同段需要有不同的页表花费了更多的内存空间，也增加了访存时间

 1. 如何实现基于段式存储管理的内存共享？

* 利用共享段，让不同进程在共享段中使用共享的页表

 1. 如何实现基于页式存储管理的内存共享？

* 在页表中让不同的页访指向相同的物理页面

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10\^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10\^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。
$$
500 = 0.9 \times 150 + 0.1 \times x \\
x = 3650
$$
（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。

针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
